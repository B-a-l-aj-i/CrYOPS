/**
 * Service for creating GitHub repositories and uploading files
 */

export interface CreateRepoOptions {
  name: string;
  description?: string;
  private?: boolean;
}

export interface CreateRepoResponse {
  id: number;
  name: string;
  full_name: string;
  html_url: string;
  clone_url: string;
  default_branch: string;
}

/**
 * Create a new GitHub repository
 */
export async function createGitHubRepo(
  accessToken: string,
  options: CreateRepoOptions
): Promise<CreateRepoResponse> {
  const response = await fetch("https://api.github.com/user/repos", {
    method: "POST",
    headers: {
      Authorization: `token ${accessToken}`,
      Accept: "application/vnd.github.v3+json",
      "Content-Type": "application/json",
      "User-Agent": "CrYOPS",
    },
    body: JSON.stringify({
      name: options.name,
      description: options.description || "Portfolio site generated by CrYOPS",
      private: options.private || false,
      auto_init: true,
    }),
  });

  if (!response.ok) {
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to create repository: ${error.message || response.statusText} (${response.status})`
    );
  }

  return response.json();
}

/**
 * Upload a file to a GitHub repository using the Contents API
 */
export async function uploadFileToRepo(
  accessToken: string,
  owner: string,
  repo: string,
  path: string,
  content: string,
  message: string = `Add ${path}`
): Promise<void> {
  // Encode content as base64
  // Buffer is available in Node.js runtime (Next.js API routes)
  const encodedContent = Buffer.from(content, "utf-8").toString("base64");

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
    {
      method: "PUT",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
        "User-Agent": "CrYOPS",
      },
      body: JSON.stringify({
        message,
        content: encodedContent,
      }),
    }
  );

  if (!response.ok) {
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to upload file ${path}: ${error.message || response.statusText} (${response.status})`
    );
  }
}

/**
 * Create blobs for all files
 */
async function createBlobsForFiles(
  accessToken: string,
  owner: string,
  repo: string,
  files: Array<{ path: string; content: string }>
): Promise<Array<{ path: string; sha: string }>> {
  const blobPromises = files.map(async (file) => {
    // Encode content as base64
    const encodedContent = Buffer.from(file.content, "utf-8").toString(
      "base64"
    );

    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/blobs`,
      {
        method: "POST",
        headers: {
          Authorization: `token ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
          "User-Agent": "CrYOPS",
        },
        body: JSON.stringify({
          content: encodedContent,
          encoding: "base64",
        }),
      }
    );

    if (!response.ok) {
      const error = await response
        .json()
        .catch(() => ({ message: response.statusText }));
      throw new Error(
        `Failed to create blob for ${file.path}: ${error.message || response.statusText} (${response.status})`
      );
    }

    const data = await response.json();
    return {
      path: file.path,
      sha: data.sha,
    };
  });

  return Promise.all(blobPromises);
}

/**
 * Create a tree with multiple files for a single commit
 */
async function createTreeWithFiles(
  accessToken: string,
  owner: string,
  repo: string,
  files: Array<{ path: string; content: string }>,
  baseTreeSha?: string
): Promise<string> {
  // Create blobs first for empty repositories
  const fileBlobs = await createBlobsForFiles(accessToken, owner, repo, files);

  const tree = fileBlobs.map((blob) => ({
    path: blob.path,
    mode: "100644" as const, // Regular file
    type: "blob" as const,
    sha: blob.sha,
  }));

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const requestBody: any = {
    tree,
  };

  // Only include base_tree if provided
  if (baseTreeSha) {
    requestBody.base_tree = baseTreeSha;
  }

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/trees`,
    {
      method: "POST",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
        "User-Agent": "CrYOPS",
      },
      body: JSON.stringify(requestBody),
    }
  );

  if (!response.ok) {
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to create tree: ${error.message || response.statusText} (${response.status})`
    );
  }

  const data = await response.json();
  return data.sha;
}

/**
 * Create a single commit with the given tree
 */
async function createSingleCommit(
  accessToken: string,
  owner: string,
  repo: string,
  treeSha: string,
  parentCommitSha?: string,
  message: string = "CrYOPS: initial commit"
): Promise<string> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const body: any = {
    message,
    tree: treeSha,
  };

  // Only include parents if they exist (for empty repositories)
  if (parentCommitSha) {
    body.parents = [parentCommitSha];
  }

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/commits`,
    {
      method: "POST",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
        "User-Agent": "CrYOPS",
      },
      body: JSON.stringify(body),
    }
  );

  if (!response.ok) {
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to create commit: ${error.message || response.statusText} (${response.status})`
    );
  }

  const data = await response.json();
  return data.sha;
}

/**
 * Update the branch reference to point to the new commit
 */
async function updateBranchReference(
  accessToken: string,
  owner: string,
  repo: string,
  branch: string,
  commitSha: string
): Promise<void> {
  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${branch}`,
    {
      method: "PATCH",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
        "User-Agent": "CrYOPS",
      },
      body: JSON.stringify({
        sha: commitSha,
        force: false,
      }),
    }
  );

  if (!response.ok) {
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to update branch reference: ${error.message || response.statusText} (${response.status})`
    );
  }
}

/**
 * Get the current branch reference and commit SHA
 */
async function getBranchReference(
  accessToken: string,
  owner: string,
  repo: string,
  branch: string = "main"
): Promise<{ ref: string; sha: string }> {
  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${branch}`,
    {
      method: "GET",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "User-Agent": "CrYOPS",
      },
    }
  );

  if (!response.ok) {
    // Try 'master' if 'main' doesn't exist (for older repos)
    if (branch === "main") {
      return getBranchReference(accessToken, owner, repo, "master");
    }
    const error = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(
      `Failed to get branch reference: ${error.message || response.statusText} (${response.status})`
    );
  }

  const data = await response.json();
  return {
    ref: data.ref,
    sha: data.object.sha,
  };
}

/**
 * Upload multiple files to a GitHub repository in a single commit
 * This replaces the sequential upload approach with a batch commit
 * Creates a single commit with message "CrYOPS: initial commit"
 */
export async function uploadFilesToRepo(
  accessToken: string,
  owner: string,
  repo: string,
  files: Array<{ path: string; content: string }>,
  onProgress?: (current: number, total: number) => void
): Promise<void> {
  if (files.length === 0) {
    return;
  }

  onProgress?.(1, 5); // Getting branch reference

  // Get current branch reference (repo will have auto_init commit)
  const { ref: branchRef, sha: parentCommitSha } = await getBranchReference(
    accessToken,
    owner,
    repo
  );

  onProgress?.(2, 5); // Creating blobs for all files

  // Create blobs first (included in tree creation)
  onProgress?.(3, 5); // Creating tree with all files

  // Create tree with all files using the existing commit as base
  const treeSha = await createTreeWithFiles(
    accessToken,
    owner,
    repo,
    files,
    parentCommitSha // Use parent commit as base
  );

  onProgress?.(4, 5); // Creating initial commit

  // Create single commit with all files
  const commitSha = await createSingleCommit(
    accessToken,
    owner,
    repo,
    treeSha,
    parentCommitSha,
    "feat(portfolio): ðŸŽ‰ instant portfolio site by CrYOPS"
  );

  onProgress?.(5, 5); // Updating branch reference

  // Update branch reference to point to new commit
  const branch = branchRef.split("/").pop() || "main";
  await updateBranchReference(accessToken, owner, repo, branch, commitSha);
}

/**
 * Check if a repository exists
 */
export async function repoExists(
  accessToken: string,
  owner: string,
  repo: string
): Promise<boolean> {
  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}`,
    {
      method: "GET",
      headers: {
        Authorization: `token ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
        "User-Agent": "CrYOPS",
      },
    }
  );

  return response.ok;
}
